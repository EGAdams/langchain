<!DOCTYPE html>
<html>
<head>
    <title>Our CodeGenAgent Documentation</title>
</head>
<body>
    <h1>Our CodeGenAgent Documentation</h1>
    <p>This document outlines the properties and methods of our CodeGenAgent, and explains the rationale behind using a Language Model (LLM) and an AgentExecutor.</p>

    <h2>Properties</h2>
    <ul>
        <li><strong>LLM:</strong> Our CodeGenAgent uses a Language Model (LLM) to generate code. The LLM is created using a model configuration and a callback manager. The model configuration specifies the provider and arguments for the LLM, and the callback manager handles callbacks from the LLM.</li>
        <li><strong>Database:</strong> Our CodeGenAgent uses a database to store logs. The logs are generated by a LogsCallbackHandler, which is added to the callback manager.</li>
        <li><strong>Prompt Parts:</strong> Our CodeGenAgent uses a list of prompt parts to guide the code generation process. Each prompt part has a role (user or system), a type, and content. The CodeGenAgent uses the prompt parts to create the prefix and format instructions.</li>
        <li><strong>AgentExecutor:</strong> Our CodeGenAgent uses an AgentExecutor to run the CodeGenAgent. The AgentExecutor is created using the CodeGenAgent and the tools, and it is run asynchronously.</li>
        <li><strong>Tools:</strong> Our CodeGenAgent uses a set of tools to assist with code generation. Each tool is assigned a custom callback manager.</li>
    </ul>

    <h2>Methods</h2>
    <ul>
        <li><strong>tool_names:</strong> This method returns the names of all the tools.</li>
        <li><strong>get_prompt_part:</strong> This method returns the content of a specific prompt part.</li>
        <li><strong>generate:</strong> This method generates code by running the AgentExecutor with an agent scratchpad and an input. The input is obtained from the user prefix prompt part.</li>
    </ul>

    <h2>Why use an LLM and an AgentExecutor?</h2>
    <p>We use a Language Model (LLM) because it provides a sophisticated way to generate code. The LLM can be trained on a large corpus of code, allowing it to generate code that is syntactically correct and semantically meaningful. The LLM also supports a variety of programming languages, making our CodeGenAgent more versatile.</p>
    <p>We use an AgentExecutor because it provides a convenient way to run the CodeGenAgent. The AgentExecutor handles the details of running the CodeGenAgent asynchronously, allowing our CodeGenAgent to generate code without blocking the main thread. This makes our CodeGenAgent more efficient and responsive.</p>
</body>
</html>